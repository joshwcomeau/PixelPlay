{"version":3,"sources":["game/fetch_cities.service.js","game/fetch_photos.service.js","game/game.ctrl.js","global/global.ctrl.js","components/game/game.module.js","components/score/score.module.js","app.routes.js","app.js","game/game_manager.service.js","user/user.service.js","score/score.service.js","services/preloader.service.js","services/reverse_geocoder.service.js"],"names":[],"mappings":"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","file":"main.min.js","sourcesContent":["function FetchCities($resource) {\n  return $resource('/api/cities');\n}\n\nangular.module('pixelPlay.game').factory(\"FetchCities\", [\"$resource\", FetchCities]);","function FetchPhotos($q) {\n  return {\n    allPhotos:      [],\n    filteredPhotos: [],\n\n    query: function(givenOpts) {\n      var \n      deferred = $q.defer(),\n      defaultOpts = {\n        feature:    'fresh_today',\n        only:       'Urban Exploration',\n        image_size: 5,\n        rpp:        100\n      },\n      opts = givenOpts || defaultOpts,\n      _this    = this;\n\n      _500px.api('/photos', opts, function (response) {\n        if (response.success) {\n          _this.allPhotos      = response.data.photos;\n          _this.filteredPhotos = _this.appropriateForGame(response.data.photos);\n\n          deferred.resolve({\n            success: true\n          });\n        } else {\n          deferred.reject({\n            success:  false,\n            status:   response.status,\n            message:  response.error_message\n          });\n        }\n      });\n\n      return deferred.promise;\n    },\n\n    // We need to strip out the photos that aren't well suited for our game.\n    // Needs to have location coordinates, at least 1200px wide, and landscape orientation.\n    appropriateForGame: function(photos) {\n      return _.filter(photos, function(photo) {\n        return (\n          photo.latitude !== null && \n          photo.longitude !== null &&\n          photo.width >= 1200 &&\n          photo.width > photo.height\n        );\n      });\n    }\n  };\n}\n\nangular.module('pixelPlay.game').factory(\"FetchPhotos\", [\"$q\", FetchPhotos]);","function GameController($scope, GameManager, FetchPhotos, bogusAnswers, Preloader, ReverseGeocoder) {\n  this.question     = 0;\n  this.page         = 1;\n  this.photoData    = null;\n  this.currentPhoto = null;\n  this.fetchPhotos  = FetchPhotos;\n  this.photoData    = FetchPhotos.filteredPhotos;\n  this.bogusCities  = bogusAnswers;\n  this.revGeocoder  = ReverseGeocoder;\n\n\n  this.loading      = false;\n  this.loadPercent  = null;\n  this.preloader    = Preloader;\n\n  this.manager      = GameManager;\n  \n\n  // Load strategy: start by loading the first x images.\n  // Then, every time we move to the next image, preload another.\n  // We should always have x images cached and ready to go.\n  // If there aren't x images left in the cache, fetch the next \n  // bunch of photos from 500px. Push to this.photoData for seamlessness.\n  this.preloadPhotos(20);\n\n  this.updateLocations();\n\n}\n\n\n// Called in app.routes.js before the view is rendered.\nGameController.resolve = {\n  getPhotos: ['FetchPhotos', function(FetchPhotos) {\n    return FetchPhotos.query();\n  }],\n  bogusAnswers: ['FetchCities', function(FetchCities) {\n    return FetchCities.query().$promise;\n  }]\n};\n\nGameController.prototype.start = function() {\n  this.manager.state = 'running';\n};\n\nGameController.prototype.getNextPhoto = function() {\n  this.currentPhoto = this.photoData.shift();\n};\n\nGameController.prototype.pickRandomCity = function() {\n  var country = _.sample(this.bogusCities);\n  return _.sample(country.cities);\n};\n\nGameController.prototype.preloadPhotos = function(num) {\n  var start     = this.question,\n      end       = this.question + (num || 1),  \n      loadArray = this.photoData.slice(start, end),\n      game      = this;\n\n  this.preloader.preloadImages(loadArray).then(\n    function handleResolve() {\n      game.getNextPhoto();\n      if ( game.manager.state === 'initial' ) game.manager.state = 'waiting';\n      console.log(\"Preload successful!\");\n    },\n    function handleReject(loc) {\n      game.manager.state = 'error';\n      console.error( \"Image failed\", loc);\n    },\n    function handleNotify(e) {\n      game.loadPercent = e.percent;\n    }\n  );\n};\n\nGameController.prototype.buildAnswers = function(photo_obj) {\n  var answers = [],\n      right_answer = photo_obj.location;\n\n  wrong_answer_1 = '';\n};\n\nGameController.prototype.updateLocations = function() {\n  var game = this;\n\n  // Here's how we'll do it. We pass in ALL of our photos, and the service does them 1 at a time.\n  // Whenever it finishes one, it throws back to .notify with the location. Then, here, we update\n  // .photoData with that location.\n  game.revGeocoder.getLocations(game.photoData).then(\n    function handleResolve() {\n      console.log(\"All images have locations\", game.photoData);\n    }, function handleReject(err) {\n      console.log(\"Uh oh, something went wrong\", err);\n    }, function handleNotify(response) {\n      game.photoData[response.index].location = response.location;\n      console.log(game.photoData);\n    }\n  );\n};\n\nGameController.$inject = ['$scope', 'GameManager', 'FetchPhotos', 'bogusAnswers', 'Preloader', 'ReverseGeocoder'];\nangular.module('pixelPlay.game').controller('GameController', ['$scope', 'GameManager', 'FetchPhotos', 'bogusAnswers', 'Preloader', 'ReverseGeocoder', GameController]);","function GlobalController($scope, User, GameManager) {\n  var global = this;\n\n  global.manager = GameManager;\n\n  global.currentUser = null;\n  global.userService = User;\n\n  $scope.$on(\"userAuthenticated\", function(e, data) {\n    $scope.$apply(function() {\n      global.currentUser = data;\n      console.log(data);\n    });\n  });\n}\n\n\nGlobalController.$inject = ['$scope', 'User', 'GameManager'];\nangular.module('pixelPlay').controller('GlobalController', ['$scope', 'User', 'GameManager', GlobalController]);","angular.module(\"pixelPlay.game\", []);","angular.module('pixelPlay.score', []);","angular.module('appRoutes', []).config(['$routeProvider', '$locationProvider', function($routeProvider, $locationProvider) {\n  $routeProvider\n    .when('/', {\n      templateUrl:  '/components/dashboard/dashboard.index.html'\n    })\n\n    // GAME ===================================================================\n    // GET :index\n    .when('/game', {\n      templateUrl:  '/components/game/game.index.html',\n      controller:   'GameController',\n      controllerAs: 'game',\n      resolve:      GameController.resolve\n    });\n\n\n    $locationProvider.html5Mode(true);\n}]);","angular\n  .module('pixelPlay', ['ngAnimate', 'ngRoute', 'ngResource', 'appRoutes', 'pixelPlay.game', 'pixelPlay.score'])\n  .run(['User', '$rootScope', function(User, $rootScope) {\n    _500px.init({\n      sdk_key: '1e6cd00470800d39b07106a70a650cdf88277901'\n    });\n\n    console.log(\"500px initialized\");\n\n    _500px.getAuthorizationStatus(User.updateUser);\n\n}]);","angular.module('pixelPlay.game').service('GameManager', function() {\n  this.score = 0;\n  \n  // Possible states are 'initial', 'waiting', 'running', 'finished', 'error'\n  this.state = 'initial';\n\n});","angular.module('pixelPlay').service('User', ['$rootScope', 'Score', function($rootScope, Score) {\n  var user = this;\n\n  user.currentUser = null;\n  user.data        = null;\n\n\n  user.login = function() {\n    _500px.login(user.updateUser);\n  };\n\n  user.logout = function() {\n    _500px.logout(user.updateUser);\n  };\n\n  // This is passed in as the callback to 500px's getAuthorizationStatus().\n  user.updateUser = function(res) {\n    if ( res === 'authorized' ) {\n      // Cool, we've got their permission. Let's get their user data.\n      _500px.api('/users', function (response) {\n        console.log(response);\n        user.currentUser = response.data.user;\n        user.data        = response;\n        $rootScope.$broadcast('userAuthenticated', response.data.user);\n      });\n    } else {\n      console.log(\"updateUser is logging out\");\n      user.currentUser = user.data = null;\n    }\n  };\n}]);","angular.module('pixelPlay.score').factory(\"Score\", [\"$resource\", function($resource) {\n  return $resource('/api/scores/:id');\n}]);","// Originally written by Ben Nadel (http://www.bennadel.com/blog/2597-preloading-images-in-angularjs-with-promises.htm)\n// Modified by Joshua Comeau\n\nangular.module('pixelPlay')\n.factory(\"Preloader\", ['$q', '$rootScope', function( $q, $rootScope ) {\n\n  // I manage the preloading of image objects. Accepts an array of image URLs.\n  function Preloader( imageLocations ) {\n\n    // Because I'm passing in an array of objects, we need to extract\n    // just the strings for image locations.\n    this.imageLocations = _.map(imageLocations, function(img) {\n      return img.image_url;\n    });\n\n    // As the images load, we'll need to keep track of the load/error\n    // counts when announing the progress on the loading.\n    this.imageCount = this.imageLocations.length;\n    this.loadCount = 0;\n    this.errorCount = 0;\n\n    // I am the possible states that the preloader can be in.\n    this.states = {\n      PENDING: 1,\n      LOADING: 2,\n      RESOLVED: 3,\n      REJECTED: 4\n    };\n\n    // I keep track of the current state of the preloader.\n    this.state = this.states.PENDING;\n\n    // When loading the images, a promise will be returned to indicate\n    // when the loading has completed (and / or progressed).\n    this.deferred = $q.defer();\n    this.promise = this.deferred.promise;\n\n  }\n\n\n  // ---\n  // STATIC METHODS.\n  // ---\n\n\n  // I reload the given images [Array] and return a promise. The promise\n  // will be resolved with the array of image locations.\n  Preloader.preloadImages = function( imageLocations ) {\n\n    var preloader = new Preloader( imageLocations );\n\n    return( preloader.load() );\n\n  };\n\n\n  // ---\n  // INSTANCE METHODS.\n  // ---\n\n\n  Preloader.prototype = {\n\n    // Best practice for \"instanceof\" operator.\n    constructor: Preloader,\n\n\n    // ---\n    // PUBLIC METHODS.\n    // ---\n\n\n    // I determine if the preloader has started loading images yet.\n    isInitiated: function isInitiated() {\n      return( this.state !== this.states.PENDING );\n    },\n\n\n    // I determine if the preloader has failed to load all of the images.\n    isRejected: function isRejected() {\n      return( this.state === this.states.REJECTED );\n    },\n\n\n    // I determine if the preloader has successfully loaded all of the images.\n    isResolved: function isResolved() {\n      return( this.state === this.states.RESOLVED );\n    },\n\n\n    // I initiate the preload of the images. Returns a promise.\n    load: function load() {\n\n        // If the images are already loading, return the existing promise.\n        if ( this.isInitiated() ) {\n          return( this.promise );\n        }\n\n        this.state = this.states.LOADING;\n\n        for ( var i = 0 ; i < this.imageCount ; i++ ) {\n          this.loadImageLocation( this.imageLocations[ i ] );\n        }\n\n        // Return the deferred promise for the load event.\n        return( this.promise );\n\n    },\n\n\n    // ---\n    // PRIVATE METHODS.\n    // ---\n\n\n    // I handle the load-failure of the given image location.\n    handleImageError: function handleImageError( imageLocation ) {\n\n      this.errorCount++;\n\n      // If the preload action has already failed, ignore further action.\n      if ( this.isRejected() ) {\n        return;\n      }\n\n      this.state = this.states.REJECTED;\n\n      this.deferred.reject( imageLocation );\n\n    },\n\n\n    // I handle the load-success of the given image location.\n    handleImageLoad: function handleImageLoad( imageLocation ) {\n\n      this.loadCount++;\n\n      // If the preload action has already failed, ignore further action.\n      if ( this.isRejected() ) {\n        return;\n      }\n\n      // Notify the progress of the overall deferred. This is different\n      // than Resolving the deferred - you can call notify many times\n      // before the ultimate resolution (or rejection) of the deferred.\n      this.deferred.notify({\n        percent: Math.ceil( this.loadCount / this.imageCount * 100 ),\n        imageLocation: imageLocation\n      });\n\n      // If all of the images have loaded, we can resolve the deferred\n      // value that we returned to the calling context.\n      if ( this.loadCount === this.imageCount ) {\n\n        this.state = this.states.RESOLVED;\n\n        this.deferred.resolve( this.imageLocations );\n\n      }\n\n    },\n\n\n    // I load the given image location and then wire the load / error\n    // events back into the preloader instance.\n    // --\n    // NOTE: The load/error events trigger a $digest.\n    loadImageLocation: function loadImageLocation( imageLocation ) {\n\n      var preloader = this;\n\n      // When it comes to creating the image object, it is critical that\n      // we bind the event handlers BEFORE we actually set the image\n      // source. Failure to do so will prevent the events from proper\n      // triggering in some browsers.\n      var image = $( new Image() ).load(\n        function( event ) {\n\n          // Since the load event is asynchronous, we have to\n          // tell AngularJS that something changed.\n          $rootScope.$apply(function() {\n            preloader.handleImageLoad( event.target.src );\n\n            // Clean up object reference to help with the\n            // garbage collection in the closure.\n            preloader = image = event = null;\n\n          });\n\n        }\n      ).error(\n        function( event ) {\n\n          // Since the load event is asynchronous, we have to\n          // tell AngularJS that something changed.\n          $rootScope.$apply(function() {\n\n            preloader.handleImageError( event.target.src );\n\n            // Clean up object reference to help with the\n            // garbage collection in the closure.\n            preloader = image = event = null;\n\n          });\n\n        }\n      ).prop( \"src\", imageLocation );\n\n    }\n\n  };\n\n\n  // Return the factory instance.\n  return( Preloader );\n\n}]);","// Written by Joshua Comeau\n\nangular.module('pixelPlay')\n.factory('ReverseGeocoder', ['$q', '$interval', function($q, $interval) {\n  var pauseLength = 1500,\n      geocoder    = new google.maps.Geocoder(),\n      deferred    = $q.defer(),\n      currentLocation, latLng;\n\n\n  var getCityAndCountry = function(geoResults) {\n    var components = geoResults[0].address_components,\n        city = [], \n        country;\n\n    // In the Maps API, 'localities' are cities. Not all areas have one though.\n    // Localities will be 'unshifted' (pushed to the FRONT)\n    // All administrative_areas will be pushed (to the BACK)\n    // That way, we can just take the first member of the array to act as our city;\n\n    _.forEach(components, function(c) {\n      if ( c.types[0] === 'locality' )\n        city.unshift(c.long_name);\n      else if ( c.types[0].substr(0, 19) === 'administrative_area')\n        city.push(c.long_name);\n      else if ( c.types[0] === 'country' )\n        country = c.long_name;\n    });\n    console.log(\"City is \", city, \" and country is \", country);\n    return {\n      city:     city[0],\n      country:  country\n    };\n  };\n\n  var getLocation = function(lat, lng, i) {\n    latLng = new google.maps.LatLng(lat, lng);\n\n    geocoder.geocode({'latLng': latLng}, function(results, status) {\n      if (status == google.maps.GeocoderStatus.OK) {\n        if (results[1]) {\n          deferred.notify({\n            location: getCityAndCountry(results),\n            index:    i\n          });\n        } else {\n          alert('No results found');\n        }\n      } else {\n        alert('Geocoder failed due to: ' + status);\n      }\n    });\n  };\n\n  return {\n    getLocations: function(arr) {\n      var iterations    = 3, // arr.length - 1,\n          currentIndex  = 0;\n\n      $interval(function() {\n        getLocation(arr[currentIndex].latitude, arr[currentIndex].longitude, currentIndex);\n        currentIndex++;\n      }, pauseLength, iterations);\n\n\n\n      return deferred.promise;\n    }\n  };\n}]);"],"sourceRoot":"/source/"}